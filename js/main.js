/* ========================================
   üöÄ GEOTRACKER PRO - JAVASCRIPT COMPLETO
   ========================================
   
   üìã RESUMEN DE FUNCIONALIDADES:
   - Obtener ubicaci√≥n GPS del usuario
   - Mostrar ubicaci√≥n en mapa interactivo
   - Convertir coordenadas a direcciones legibles
   - Permitir clicks en mapa para seleccionar puntos
   - Calcular distancias entre ubicaciones
   - Compartir ubicaci√≥n actual
   - Seguimiento en tiempo real
   
   üåê APIS UTILIZADAS:
   1. Geolocation API (navegador) - GPS
   2. Nominatim API (OpenStreetMap) - Geocodificaci√≥n
   3. ipapi.co - Informaci√≥n de pa√≠s
   4. Leaflet.js - Mapas interactivos
   5. Web Share API (navegador) - Compartir
   6. Clipboard API (navegador) - Copiar texto
   
======================================== */

/* ========================================
   üìã VARIABLES GLOBALES - ESTADO DE LA APP
   ========================================
   Estas variables mantienen el estado de toda la aplicaci√≥n
   y permiten que las funciones se comuniquen entre s√≠
======================================== */

// üó∫Ô∏è VARIABLES DEL MAPA
let map;                    // Instancia principal del mapa Leaflet
let userMarker;            // Marcador AZUL que muestra TU ubicaci√≥n actual
let clickedMarker;         // Marcador ROJO que muestra donde hiciste click
let routeControl;          // Objeto que contiene l√≠neas de ruta y distancias

// üéØ VARIABLES DE SEGUIMIENTO
let isTracking = false;    // Boolean: ¬øest√° activado el seguimiento autom√°tico?
let watchId;               // ID num√©rico para poder cancelar watchPosition()

// üìä VARIABLES DE DATOS
let updateCount = 0;       // Contador: cu√°ntas veces se actualiz√≥ la ubicaci√≥n
let locationHistory = [];  // Array: historial de todas las ubicaciones visitadas
let currentUserLocation = null; // Objeto: tu ubicaci√≥n actual {lat, lng}

/* ========================================
   üöÄ INICIALIZACI√ìN DE LA APLICACI√ìN
   ========================================
   Esta es la primera funci√≥n que se ejecuta cuando
   el navegador termina de cargar el HTML
======================================== */

document.addEventListener('DOMContentLoaded', function() {
    // DOMContentLoaded se dispara cuando el HTML est√° completamente cargado
    // pero antes de que terminen de cargar im√°genes y otros recursos
    
    console.log('üöÄ Iniciando GeoTracker Pro...');
    
    // PASO 1: Crear efectos visuales de fondo
    initializeParticles();     // Crear 50 part√≠culas flotantes animadas
    
    // PASO 2: Configurar el mapa interactivo
    initializeMap();           // Inicializar Leaflet.js con OpenStreetMap
    
    // PASO 3: Solicitar ubicaci√≥n del usuario
    getCurrentLocation();      // Llamar a Geolocation API del navegador
});

/* ========================================
   ‚ú® SISTEMA DE PART√çCULAS DECORATIVAS
   ========================================
   Crea elementos visuales que flotan desde abajo hacia arriba
   para darle un efecto moderno y din√°mico al fondo
======================================== */

function initializeParticles() {
    console.log('‚ú® Creando part√≠culas decorativas...');
    
    // Buscar el contenedor HTML donde van las part√≠culas
    const particlesContainer = document.getElementById('particles');
    
    // Crear 50 part√≠culas individuales
    for (let i = 0; i < 50; i++) {
        // Crear elemento div para cada part√≠cula
        const particle = document.createElement('div');
        particle.className = 'particle';  // Asignar clase CSS para estilos
        
        // POSICI√ìN HORIZONTAL aleatoria (0% - 100% del ancho de pantalla)
        particle.style.left = Math.random() * 100 + '%';
        
        // DELAY aleatorio para que no todas empiecen al mismo tiempo (0-20 segundos)
        particle.style.animationDelay = Math.random() * 20 + 's';
        
        // DURACI√ìN aleatoria de la animaci√≥n (15-25 segundos)
        particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
        
        // Agregar la part√≠cula al DOM
        particlesContainer.appendChild(particle);
    }
    
    console.log('‚úÖ 50 part√≠culas creadas exitosamente');
}

/* ========================================
   üó∫Ô∏è INICIALIZACI√ìN DEL MAPA - LEAFLET.JS
   ========================================
   Configura el mapa interactivo usando la librer√≠a Leaflet
   y tiles (im√°genes) de OpenStreetMap
======================================== */

function initializeMap() {
    console.log('üó∫Ô∏è Inicializando mapa...');
    
    // CREAR INSTANCIA DEL MAPA
    // L.map() es la funci√≥n principal de Leaflet.js
    // 'map' es el ID del div HTML donde se renderizar√° el mapa
    // .setView([lat, lng], zoom) establece la vista inicial
    map = L.map('map').setView([19.4326, -99.1332], 13);
    // Coordenadas de Ciudad de M√©xico como ubicaci√≥n por defecto
    // Zoom 13 = vista de ciudad (0=mundo, 18=calle)
    
    // AGREGAR CAPA DE TILES (las im√°genes del mapa)
    // Los tiles son im√°genes cuadradas que forman el mapa completo
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'  // Cr√©ditos obligatorios
    }).addTo(map);  // .addTo(map) agrega la capa al mapa
    
    // URL explicada:
    // {s} = subdominio (a, b, c) para distribuci√≥n de carga
    // {z} = nivel de zoom (0-18)
    // {x} = coordenada X del tile
    // {y} = coordenada Y del tile
    
    // APLICAR FILTROS CSS para mejorar la apariencia
    map.getContainer().style.filter = 'contrast(1.1) saturate(1.2)';
    // contrast(1.1) = aumentar contraste 10%
    // saturate(1.2) = aumentar saturaci√≥n 20%

    // ‚≠ê EVENTO CR√çTICO: Detectar clicks en el mapa
    // Cada vez que el usuario haga click en cualquier parte del mapa,
    // se ejecutar√° la funci√≥n onMapClick
    map.on('click', onMapClick);
    
    console.log('‚úÖ Mapa inicializado exitosamente');
}

/* ========================================
   üìç GEOLOCATION API - OBTENER UBICACI√ìN
   ========================================
   Funci√≥n principal que solicita la ubicaci√≥n GPS del usuario
   usando la API nativa del navegador web
======================================== */

function getCurrentLocation() {
    console.log('üìç Verificando soporte de geolocalizaci√≥n...');
    
    if (!navigator.geolocation) {
        showError('‚ùå Tu navegador no soporta geolocalizaci√≥n');
        return;
    }

    // VERIFICAR PERMISOS PRIMERO
    if (navigator.permissions) {
        navigator.permissions.query({name: 'geolocation'}).then(function(result) {
            console.log('üîê Estado de permisos:', result.state);
            
            if (result.state === 'denied') {
                showPermissionHelp();
            } else {
                requestLocation();
            }
        });
    } else {
        // Fallback para navegadores sin Permissions API
        requestLocation();
    }
    
    // En este punto la funci√≥n termina, pero las callbacks se ejecutar√°n
    // de forma as√≠ncrona cuando el navegador obtenga (o falle) la ubicaci√≥n
}

/* ========================================
   ‚úÖ MANEJO EXITOSO DE GEOLOCALIZACI√ìN
   ========================================
   Esta funci√≥n se ejecuta autom√°ticamente cuando
   el usuario acepta compartir su ubicaci√≥n y se obtiene exitosamente
======================================== */

function handleLocationSuccess(position) {
    console.log('‚úÖ Ubicaci√≥n obtenida exitosamente:', position);
    
    // EXTRAER DATOS DEL OBJETO POSITION
    // El navegador retorna un objeto complejo, extraemos lo que necesitamos
    const { latitude, longitude, accuracy } = position.coords;
    // Tambi√©n est√°n disponibles: speed, heading, altitude, altitudeAccuracy
    
    console.log(`üìç Coordenadas: ${latitude}, ${longitude}`);
    console.log(`üéØ Precisi√≥n: ${accuracy} metros`);
    
    // ACTUALIZAR ESTADO GLOBAL DE LA APLICACI√ìN
    updateCount++;  // Incrementar contador de actualizaciones
    console.log(`üìä Actualizaci√≥n #${updateCount}`);
    
    // Agregar nueva ubicaci√≥n al historial con timestamp
    locationHistory.push({ 
        lat: latitude, 
        lng: longitude, 
        timestamp: new Date(),
        accuracy: accuracy
    });
    
    // Guardar ubicaci√≥n actual para poder calcular distancias despu√©s
    currentUserLocation = { lat: latitude, lng: longitude };
    
    // ACTUALIZAR INTERFAZ DE USUARIO
    console.log('üîÑ Actualizando interfaz...');
    
    updateLocationDisplay(position);    // Llenar panel izquierdo con datos GPS
    updateMap(latitude, longitude);     // Mover mapa a tu ubicaci√≥n y agregar marcador azul
    updateStats(accuracy);              // Actualizar estad√≠sticas en cards inferiores
    updateStatus(true);                 // Cambiar indicador de estado a verde (activo)
    
    // üåê LLAMADA A API DE GEOCODIFICACI√ìN
    // Convertir las coordenadas num√©ricas en una direcci√≥n legible
    console.log('üåê Obteniendo direcci√≥n...');
    getAddressFromCoordinates(latitude, longitude);
}

/* ========================================
   ‚ùå MANEJO DE ERRORES DE GEOLOCALIZACI√ìN
   ========================================
   Esta funci√≥n se ejecuta cuando hay problemas
   al obtener la ubicaci√≥n del usuario
======================================== */

function handleLocationError(error) {
    console.error('‚ùå Error de geolocalizaci√≥n:', error);
    
    let message = 'Error desconocido';
    
    // IDENTIFICAR EL TIPO ESPEC√çFICO DE ERROR
    // La Geolocation API define c√≥digos de error est√°ndar
    switch(error.code) {
        case error.PERMISSION_DENIED:
            // El usuario deneg√≥ el permiso de ubicaci√≥n
            message = 'Permiso de geolocalizaci√≥n denegado';
            console.error('üö´ Usuario deneg√≥ permisos de ubicaci√≥n');
            break;
        case error.POSITION_UNAVAILABLE:
            // No se pudo determinar la ubicaci√≥n (GPS desactivado, sin se√±al, etc.)
            message = 'Informaci√≥n de ubicaci√≥n no disponible';
            console.error('üì° No se pudo obtener se√±al GPS');
            break;
        case error.TIMEOUT:
            // Se agot√≥ el tiempo de espera definido en options.timeout
            message = 'Tiempo de espera agotado';
            console.error('‚è∞ Timeout: tard√≥ m√°s de 10 segundos');
            break;
        default:
            console.error('‚ùì Error desconocido:', error.message);
    }
    
    // MOSTRAR ERROR AL USUARIO Y ACTUALIZAR ESTADO
    showError(message);     // Mostrar mensaje en la interfaz
    updateStatus(false);    // Cambiar indicador de estado a rojo (inactivo)
}

/* ========================================
   üìä ACTUALIZAR PANEL DE INFORMACI√ìN GPS
   ========================================
   Toma todos los datos obtenidos del GPS y los
   muestra de forma organizada en el panel izquierdo
======================================== */

function updateLocationDisplay(position) {
    console.log('üìä Actualizando display de ubicaci√≥n...');
    
    // EXTRAER TODOS LOS DATOS DISPONIBLES del objeto position
    const { latitude, longitude, accuracy, speed, heading } = position.coords;
    const timestamp = new Date(position.timestamp);  // Convertir timestamp a objeto Date
    
    // Buscar el elemento HTML donde mostrar la informaci√≥n
    const locationInfo = document.getElementById('locationInfo');
    
    // GENERAR HTML DIN√ÅMICO usando template literals
    // Los template literals (backticks ``) permiten crear strings multil√≠nea
    // y incluir variables con ${variable}
    locationInfo.innerHTML = `
        <div class="info-item">
            <span class="info-label">Latitud:</span>
            <span class="info-value">${latitude.toFixed(6)}¬∞</span>
        </div>
        <div class="info-item">
            <span class="info-label">Longitud:</span>
            <span class="info-value">${longitude.toFixed(6)}¬∞</span>
        </div>
        <div class="info-item">
            <span class="info-label">Precisi√≥n:</span>
            <span class="info-value">${accuracy?.toFixed(0) || 'N/A'} m</span>
        </div>
        <div class="info-item">
            <span class="info-label">Velocidad:</span>
            <span class="info-value">${speed ? (speed * 3.6).toFixed(1) + ' km/h' : 'N/A'}</span>
        </div>
        <div class="info-item">
            <span class="info-label">Direcci√≥n:</span>
            <span class="info-value">${heading?.toFixed(0) + '¬∞' || 'N/A'}</span>
        </div>
        <div class="info-item">
            <span class="info-label">Hora:</span>
            <span class="info-value">${timestamp.toLocaleTimeString()}</span>
        </div>
    `;
    
    // EXPLICACI√ìN DE C√ÅLCULOS:
    // .toFixed(6) = mostrar 6 decimales (precisi√≥n de ~1 metro)
    // speed * 3.6 = convertir m/s a km/h
    // ?. = optional chaining (no falla si el valor es null)
    // || 'N/A' = mostrar 'N/A' si el valor no est√° disponible
    
    console.log('‚úÖ Panel de ubicaci√≥n actualizado');
}

/* ========================================
   üó∫Ô∏è ACTUALIZAR MAPA CON MARCADOR AZUL
   ========================================
   Mueve el mapa a tu ubicaci√≥n actual y agrega
   un marcador azul pulsante que te representa
======================================== */

function updateMap(lat, lng) {
    console.log(`üó∫Ô∏è Actualizando mapa: ${lat}, ${lng}`);
    
    // REMOVER MARCADOR ANTERIOR (si existe)
    // Evita que se acumulen marcadores azules en el mapa
    if (userMarker) {
        map.removeLayer(userMarker);  // Leaflet funci√≥n para quitar elementos del mapa
        console.log('üßπ Marcador anterior removido');
    }

    // CREAR ICONO PERSONALIZADO CON ANIMACI√ìN CSS
    // L.divIcon permite crear marcadores con HTML personalizado
    const pulsingIcon = L.divIcon({
        className: 'pulsing-marker',     // Clase CSS (opcional)
        html: `<div style="
            width: 20px;
            height: 20px;
            background: #4facfe;         /* Color azul corporativo */
            border: 3px solid white;     /* Borde blanco para contraste */
            border-radius: 50%;          /* Hacer c√≠rculo perfecto */
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.6); /* Sombra brillante */
            animation: pulse 2s infinite; /* Animaci√≥n pulsante CSS */
        "></div>`,
        iconSize: [20, 20],              // Tama√±o del icono en p√≠xeles
        iconAnchor: [10, 10]             // Punto de anclaje (centro del c√≠rculo)
    });

    // AGREGAR MARCADOR AL MAPA
    // L.marker crea el marcador en las coordenadas especificadas
    userMarker = L.marker([lat, lng], { icon: pulsingIcon }).addTo(map);
    console.log('üìç Marcador azul agregado');
    
    // AGREGAR C√çRCULO DE PRECISI√ìN (opcional)
    // Muestra un √°rea circular que representa la precisi√≥n del GPS
    L.circle([lat, lng], {
        color: '#4facfe',       // Color del borde del c√≠rculo
        fillColor: '#4facfe',   // Color del relleno
        fillOpacity: 0.1,       // Transparencia del relleno (10%)
        radius: 100             // Radio en metros (ajustable seg√∫n precisi√≥n)
    }).addTo(map);
    console.log('‚≠ï C√≠rculo de precisi√≥n agregado');

    // CENTRAR MAPA EN LA NUEVA UBICACI√ìN
    // .setView mueve la vista del mapa a las coordenadas especificadas
    map.setView([lat, lng], 16);  // Zoom nivel 16 = vista de barrio
    console.log('üéØ Mapa centrado en nueva ubicaci√≥n');
}

/* ========================================
   üåê API NOMINATIM - GEOCODIFICACI√ìN INVERSA
   ========================================
   Esta es la funci√≥n m√°s compleja de la aplicaci√≥n.
   Convierte coordenadas num√©ricas en direcciones legibles
   usando la API gratuita de OpenStreetMap
======================================== */

async function getAddressFromCoordinates(lat, lng) {
    console.log(`üåê Obteniendo direcci√≥n para: ${lat}, ${lng}`);
    
    // MOSTRAR ESTADO DE CARGA AL USUARIO
    // Importante para UX: el usuario debe saber que algo est√° pasando
    const addressInfo = document.getElementById('addressInfo');
    addressInfo.innerHTML = `
        <div class="loading">
            <div class="spinner"></div>
            <span>Obteniendo direcci√≥n...</span>
        </div>
    `;
    
    try {
        // üåê LLAMADAS A M√öLTIPLES APIs EN PARALELO
        // Promise.allSettled permite que una API falle sin afectar las otras
        console.log('üöÄ Iniciando llamadas a APIs...');
        
        const [nominatimData, ipLocationData] = await Promise.allSettled([
            
            // üåê API #1: NOMINATIM (OpenStreetMap) - Principal
            fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`),
            
            // üåê API #2: IPAPI.CO - Respaldo para informaci√≥n de pa√≠s
            fetch(`https://ipapi.co/json/`)
        ]);

        // VARIABLES PARA ALMACENAR RESPUESTAS
        let addressData = null;
        let countryData = null;

        // PROCESAR RESPUESTA DE NOMINATIM
        if (nominatimData.status === 'fulfilled') {
            console.log('‚úÖ Nominatim API respondi√≥ exitosamente');
            const nominatimResponse = await nominatimData.value.json();
            addressData = nominatimResponse;
            console.log('üìç Datos de Nominatim:', addressData);
        } else {
            console.warn('‚ö†Ô∏è Nominatim API fall√≥:', nominatimData.reason);
        }

        // PROCESAR RESPUESTA DE IPAPI (respaldo)
        if (ipLocationData.status === 'fulfilled') {
            console.log('‚úÖ ipapi.co respondi√≥ exitosamente');
            countryData = await ipLocationData.value.json();
            console.log('üåç Datos de ipapi:', countryData);
        } else {
            console.warn('‚ö†Ô∏è ipapi.co fall√≥:', ipLocationData.reason);
        }

        // MOSTRAR INFORMACI√ìN OBTENIDA
        displayAddressInfo(addressData, countryData);
        updateAddressStatus(true);  // Cambiar indicador a verde

    } catch (error) {
        // MANEJO DE ERRORES DE RED
        console.error('‚ùå Error en APIs de geocodificaci√≥n:', error);
        addressInfo.innerHTML = `
            <div class="error">
                Error al obtener informaci√≥n de direcci√≥n
            </div>
        `;
        updateAddressStatus(false);  // Cambiar indicador a rojo
    }
}

/* ========================================
   üìã MOSTRAR INFORMACI√ìN DE DIRECCI√ìN
   ========================================
   Procesa las respuestas de las APIs de geocodificaci√≥n
   y las muestra de forma organizada en el panel central
======================================== */

function displayAddressInfo(addressData, countryData) {
    console.log('üìã Procesando informaci√≥n de direcci√≥n...');
    
    const addressInfo = document.getElementById('addressInfo');
    
    // VERIFICAR QUE TENEMOS DATOS V√ÅLIDOS
    if (!addressData) {
        console.warn('‚ö†Ô∏è No hay datos de direcci√≥n disponibles');
        addressInfo.innerHTML = `
            <div class="error">
                No se pudo obtener informaci√≥n de direcci√≥n
            </div>
        `;
        return;  // Salir de la funci√≥n si no hay datos
    }

    // EXTRAER INFORMACI√ìN ESPEC√çFICA de la respuesta de Nominatim
    // El objeto address contiene todos los componentes de la direcci√≥n
    const address = addressData.address || {};
    
    console.log('üè† Componentes de direcci√≥n:', address);

    // EXTRAER CADA CAMPO (pueden existir o no dependiendo del lugar)
    const house_number = address.house_number || '';           // N√∫mero de casa/edificio
    const road = address.road || address.street || '';         // Nombre de calle/avenida
    const neighbourhood = address.neighbourhood || address.suburb || '';  // Barrio/colonia
    const city = address.city || address.town || address.village || address.municipality || '';  // Ciudad
    const county = address.county || address.state_district || '';     // Condado/municipio
    const state = address.state || address.province || '';     // Estado/provincia
    const country = address.country || (countryData?.country_name) || '';  // Pa√≠s
    const postcode = address.postcode || '';                   // C√≥digo postal
    const country_code = address.country_code || (countryData?.country_code) || '';  // C√≥digo ISO del pa√≠s

    // OBTENER EMOJI DE BANDERA DEL PA√çS
    const flagEmoji = getFlagEmoji(country_code);
    console.log(`üè≥Ô∏è Bandera: ${flagEmoji} (${country_code})`);

    // ACTUALIZAR ESTAD√çSTICA DE PA√çS en las cards inferiores
    document.getElementById('currentCountry').textContent = flagEmoji;

    // CREAR DIRECCI√ìN SIMPLIFICADA (como me pediste: calle, ciudad, pa√≠s)
    const streetAddress = house_number && road ? `${house_number} ${road}` : (road || 'Direcci√≥n no especificada');
    const fullSimpleAddress = `${streetAddress}, ${city || 'Ciudad no especificada'}, ${country || 'Pa√≠s no especificado'}`;
    
    console.log('üìç Direcci√≥n simplificada:', fullSimpleAddress);

    // GENERAR HTML DIN√ÅMICO con toda la informaci√≥n
    // Usamos template literals y operador ternario para mostrar campos opcionales
    addressInfo.innerHTML = `
        <div class="info-item">
            <span class="info-label">Direcci√≥n:</span>
            <span class="info-value" style="font-size: 0.95em; line-height: 1.4;">${fullSimpleAddress}</span>
        </div>
        ${neighbourhood ? `
        <div class="info-item">
            <span class="info-label">Barrio/Colonia:</span>
            <span class="info-value">${neighbourhood}</span>
        </div>` : ''}
        ${county ? `
        <div class="info-item">
            <span class="info-label">Condado/Municipio:</span>
            <span class="info-value">${county}</span>
        </div>` : ''}
        ${state ? `
        <div class="info-item">
            <span class="info-label">Estado/Provincia:</span>
            <span class="info-value">${state}</span>
        </div>` : ''}
        ${postcode ? `
        <div class="info-item">
            <span class="info-label">C√≥digo Postal:</span>
            <span class="info-value">${postcode}</span>
        </div>` : ''}
        <div class="info-item">
            <span class="info-label">Tipo de Lugar:</span>
            <span class="info-value">${getPlaceType(addressData)}</span>
        </div>
    `;
    
    console.log('‚úÖ Informaci√≥n de direcci√≥n mostrada');
}

/* ========================================
   üè≥Ô∏è SISTEMA DE BANDERAS POR PA√çS
   ========================================
   Convierte c√≥digos de pa√≠s ISO (mx, us, etc.)
   en emojis de banderas correspondientes
======================================== */

function getFlagEmoji(countryCode) {
    if (!countryCode) {
        console.log('üåç Sin c√≥digo de pa√≠s, usando emoji gen√©rico');
        return 'üåç';  // Emoji por defecto si no hay c√≥digo
    }
    
    console.log(`üè≥Ô∏è Buscando bandera para: ${countryCode}`);
    
    // MAPEO DE C√ìDIGOS ISO 3166-1 ALPHA-2 a EMOJIS DE BANDERAS
    // Solo incluimos los pa√≠ses m√°s comunes para no hacer el objeto muy grande
    const flags = {
        // Am√©rica
        'mx': 'üá≤üáΩ', 'us': 'üá∫üá∏', 'ca': 'üá®üá¶', 'br': 'üáßüá∑', 'ar': 'üá¶üá∑',
        'co': 'üá®üá¥', 'pe': 'üáµüá™', 'cl': 'üá®üá±', 've': 'üáªüá™', 'ec': 'üá™üá®',
        
        // Europa
        'es': 'üá™üá∏', 'fr': 'üá´üá∑', 'de': 'üá©üá™', 'it': 'üáÆüáπ', 'gb': 'üá¨üáß',
        
        // Asia
        'jp': 'üáØüáµ', 'kr': 'üá∞üá∑', 'cn': 'üá®üá≥', 'in': 'üáÆüá≥',
        
        // Ocean√≠a
        'au': 'üá¶üá∫'
    };
    
    // Buscar bandera espec√≠fica o retornar emoji gen√©rico
    const flag = flags[countryCode.toLowerCase()] || 'üåç';
    console.log(`üè≥Ô∏è Bandera encontrada: ${flag}`);
    return flag;
}

/* ========================================
   üè¢ CLASIFICACI√ìN INTELIGENTE DE LUGARES
   ========================================
   Analiza los datos de Nominatim para determinar
   qu√© tipo de lugar es (residencial, comercial, etc.)
======================================== */

function getPlaceType(addressData) {
    const address = addressData.address || {};
    
    console.log('üè¢ Clasificando tipo de lugar...');
    
    // CLASIFICAR SEG√öN CARACTER√çSTICAS ESPEC√çFICAS
    // Revisamos en orden de especificidad (m√°s espec√≠fico primero)
    
    if (address.house_number) {
        console.log('üè† Detectado: Residencial (tiene n√∫mero de casa)');
        return 'üè† Residencial';
    }
    
    if (address.shop || address.amenity === 'shop') {
        console.log('üè™ Detectado: Comercial');
        return 'üè™ Comercial';
    }
    
    if (address.amenity === 'restaurant') {
        console.log('üçΩÔ∏è Detectado: Restaurante');
        return 'üçΩÔ∏è Restaurante';
    }
    
    if (address.amenity === 'hospital') {
        console.log('üè• Detectado: Hospital');
        return 'üè• Hospital';
    }
    
    if (address.amenity === 'school') {
        console.log('üè´ Detectado: Escuela');
        return 'üè´ Escuela';
    }
    
    if (address.amenity === 'bank') {
        console.log('üè¶ Detectado: Banco');
        return 'üè¶ Banco';
    }
    
    if (address.highway) {
        console.log('üõ£Ô∏è Detectado: V√≠a');
        return 'üõ£Ô∏è V√≠a';
    }
    
    if (address.natural) {
        console.log('üåø Detectado: √Årea Natural');
        return 'üåø √Årea Natural';
    }
    
    if (address.leisure) {
        console.log('üéØ Detectado: Recreativo');
        return 'üéØ Recreativo';
    }
    
    console.log('üìç Tipo gen√©rico asignado');
    return 'üìç Ubicaci√≥n General';  // Clasificaci√≥n por defecto
}

/* ========================================
   üñ±Ô∏è MANEJO DE CLICKS EN EL MAPA
   ========================================
   Esta funci√≥n se ejecuta CADA VEZ que el usuario
   hace click en cualquier parte del mapa
======================================== */

function onMapClick(e) {
    // OBTENER COORDENADAS DEL CLICK
    // Leaflet proporciona las coordenadas exactas donde se hizo click
    const { lat, lng } = e.latlng;
    console.log(`üñ±Ô∏è Click en mapa: ${lat}, ${lng}`);
    
    // REMOVER MARCADOR ROJO ANTERIOR (si existe)
    // Evita que se acumulen marcadores rojos en el mapa
    if (clickedMarker) {
        map.removeLayer(clickedMarker);
        console.log('üßπ Marcador rojo anterior removido');
    }

    // CREAR ICONO PARA PUNTO CLICKEADO (rojo y m√°s peque√±o que el azul)
    const clickIcon = L.divIcon({
        className: 'clicked-marker',     // Clase CSS opcional
        html: `<div style="
            width: 16px;
            height: 16px;
            background: #ff4757;           /* Color rojo distintivo */
            border: 2px solid white;       /* Borde blanco para contraste */
            border-radius: 50%;            /* C√≠rculo perfecto */
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.6); /* Sombra roja */
            animation: pulse 2s infinite;  /* Animaci√≥n pulsante */
        "></div>`,
        iconSize: [16, 16],              // M√°s peque√±o que el marcador azul
        iconAnchor: [8, 8]               // Centro del c√≠rculo
    });

    // AGREGAR MARCADOR ROJO AL MAPA
    clickedMarker = L.marker([lat, lng], { icon: clickIcon }).addTo(map);
    console.log('üî¥ Marcador rojo agregado');
    
    // OBTENER INFORMACI√ìN DEL LUGAR CLICKEADO
    // Hacer nueva llamada a Nominatim para este punto espec√≠fico
    getClickedLocationInfo(lat, lng);
    
    // CALCULAR Y MOSTRAR RUTA (si tenemos ubicaci√≥n del usuario)
    if (currentUserLocation) {
        console.log('üìè Calculando ruta...');
        calculateRoute(currentUserLocation, { lat, lng });
    } else {
        console.warn('‚ö†Ô∏è No hay ubicaci√≥n de usuario para calcular ruta');
    }
}

/* ========================================
   üìç OBTENER INFO DE LUGAR CLICKEADO
   ========================================
   Hace una nueva llamada a Nominatim API para obtener
   informaci√≥n espec√≠fica del punto donde hizo click el usuario
======================================== */

async function getClickedLocationInfo(lat, lng) {
    console.log(`üìç Obteniendo info de punto clickeado: ${lat}, ${lng}`);
    
    try {
        // üåê NUEVA LLAMADA A NOMINATIM API
        // Similar a la anterior pero para el punto clickeado
        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
        const data = await response.json();
        
        console.log('üìç Datos del lugar clickeado:', data);
        
        // EXTRAER INFORMACI√ìN B√ÅSICA PARA EL POPUP
        const address = data.address || {};
        const house_number = address.house_number || '';
        const road = address.road || address.street || '';
        const city = address.city || address.town || address.village || address.municipality || '';
        const country = address.country || '';
        const country_code = address.country_code || '';
        const flagEmoji = getFlagEmoji(country_code);

        // CREAR DIRECCI√ìN SIMPLIFICADA PARA MOSTRAR
        const streetAddress = house_number && road ? `${house_number} ${road}` : (road || 'Direcci√≥n no especificada');
        const fullSimpleAddress = `${streetAddress}, ${city || 'Ciudad no especificada'}, ${country || 'Pa√≠s no especificado'}`;

        // CREAR CONTENIDO DEL POPUP
        // HTML que se mostrar√° en una ventana flotante sobre el marcador
        const popupContent = `
            <div style="min-width: 200px; font-family: 'Segoe UI', sans-serif;">
                <h3 style="margin: 0 0 10px 0; color: #333; font-size: 1.1em;">
                    üìç Ubicaci√≥n Seleccionada
                </h3>
                <p style="margin: 5px 0; color: #666; font-size: 0.9em;">
                    <strong>Direcci√≥n:</strong><br>
                    ${fullSimpleAddress}
                </p>
                <p style="margin: 5px 0; color: #666; font-size: 0.9em;">
                    <strong>Coordenadas:</strong><br>
                    ${lat.toFixed(6)}, ${lng.toFixed(6)}
                </p>
                <p style="margin: 5px 0; color: #666; font-size: 0.9em;">
                    <strong>Tipo:</strong> ${getPlaceType(data)}
                </p>
            </div>
        `;

        // MOSTRAR POPUP EN EL MARCADOR ROJO
        // .bindPopup asocia el contenido HTML al marcador
        // .openPopup() lo muestra inmediatamente
        clickedMarker.bindPopup(popupContent).openPopup();
        console.log('üí¨ Popup mostrado con informaci√≥n');
        
    } catch (error) {
        console.error('‚ùå Error obteniendo info del lugar clickeado:', error);
        
        // POPUP DE FALLBACK en caso de error de red
        clickedMarker.bindPopup(`
            <div style="font-family: 'Segoe UI', sans-serif;">
                <h3 style="margin: 0 0 10px 0; color: #333;">üìç Ubicaci√≥n</h3>
                <p>Coordenadas: ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                <p style="color: #ff4757;">No se pudo obtener informaci√≥n detallada</p>
            </div>
        `).openPopup();
    }
}

/* ========================================
   üìè SISTEMA DE C√ÅLCULO DE RUTAS
   ========================================
   Dibuja una l√≠nea punteada entre tu ubicaci√≥n
   y el punto clickeado, mostrando la distancia
======================================== */

function calculateRoute(from, to) {
    console.log(`üìè Calculando ruta de ${from.lat},${from.lng} a ${to.lat},${to.lng}`);
    
    // REMOVER RUTA ANTERIOR (si existe)
    // Evita que se acumulen l√≠neas en el mapa
    if (routeControl) {
        routeControl.remove();  // Funci√≥n personalizada que definimos m√°s abajo
        routeControl = null;
        console.log('üßπ Ruta anterior removida');
    }

    // CALCULAR DISTANCIA EN L√çNEA RECTA
    // Usa la f√≥rmula matem√°tica de Haversine para precisi√≥n geogr√°fica
    const distance = calculateDistance(from.lat, from.lng, to.lat, to.lng);
    console.log(`üìè Distancia calculada: ${distance}`);
    
    // CREAR L√çNEA DE RUTA VISUAL en el mapa
    // L.polyline dibuja una l√≠nea entre m√∫ltiples puntos
    const routeLine = L.polyline([
        [from.lat, from.lng],    // Punto de inicio (tu ubicaci√≥n azul)
        [to.lat, to.lng]         // Punto final (marcador rojo clickeado)
    ], {
        color: '#4facfe',        // Color azul que combina con el tema
        weight: 4,               // Grosor de l√≠nea en p√≠xeles
        opacity: 0.8,            // Transparencia (80% opaco)
        dashArray: '10, 10'      // Patr√≥n de l√≠nea punteada (10px l√≠nea, 10px espacio)
    }).addTo(map);

    // CALCULAR PUNTO MEDIO para mostrar la distancia
    // El marcador de distancia aparece exactamente en el centro de la l√≠nea
    const midLat = (from.lat + to.lat) / 2;
    const midLng = (from.lng + to.lng) / 2;
    console.log(`üìç Punto medio: ${midLat}, ${midLng}`);
    
    // CREAR MARCADOR DE DISTANCIA en el punto medio
    // Muestra la distancia calculada en un label flotante
    const distanceMarker = L.marker([midLat, midLng], {
        icon: L.divIcon({
            className: 'distance-marker',    // Clase CSS opcional
            html: `<div style="
                background: rgba(79, 172, 254, 0.9); /* Fondo azul semitransparente */
                color: white;                         /* Texto blanco */
                padding: 5px 10px;                    /* Espacio interno */
                border-radius: 15px;                  /* Bordes redondeados */
                font-size: 12px;                      /* Tama√±o de fuente */
                font-weight: bold;                    /* Texto en negrita */
                box-shadow: 0 2px 10px rgba(0,0,0,0.3); /* Sombra sutil */
                white-space: nowrap;                  /* No quebrar l√≠nea */
            ">üìè ${distance}</div>`,  // Mostrar la distancia con emoji
            iconSize: [80, 30],       // Tama√±o estimado del contenedor
            iconAnchor: [40, 15]      // Punto de anclaje (centro)
        })
    }).addTo(map);

    // GUARDAR REFERENCIAS para poder limpiar despu√©s
    // Creamos un objeto personalizado con funci√≥n de limpieza
    routeControl = {
        line: routeLine,             // Referencia a la l√≠nea punteada
        marker: distanceMarker,      // Referencia al marcador de distancia
        remove: function() {         // Funci√≥n personalizada para limpiar todo
            console.log('üßπ Removiendo elementos de ruta...');
            map.removeLayer(routeLine);      // Quitar l√≠nea del mapa
            map.removeLayer(distanceMarker); // Quitar marcador de distancia
        }
    };

    // AJUSTAR VISTA DEL MAPA para mostrar ambos puntos
    // L.latLngBounds crea un rect√°ngulo que contiene ambos puntos
    const bounds = L.latLngBounds([
        [from.lat, from.lng],        // Esquina 1: tu ubicaci√≥n
        [to.lat, to.lng]             // Esquina 2: punto clickeado
    ]);
    // .fitBounds ajusta el zoom para que ambos puntos sean visibles
    map.fitBounds(bounds, { padding: [20, 20] });  // Con 20px de margen
    
    console.log('‚úÖ Ruta dibujada y vista ajustada');
}

/* ========================================
   üßÆ C√ÅLCULO DE DISTANCIA - F√ìRMULA DE HAVERSINE
   ========================================
   Calcula la distancia real entre dos puntos en la Tierra
   considerando su curvatura (m√°s preciso que l√≠nea recta euclidiana)
======================================== */

function calculateDistance(lat1, lng1, lat2, lng2) {
    console.log(`üßÆ Calculando distancia Haversine...`);
    
    // CONSTANTE: Radio promedio de la Tierra en kil√≥metros
    const R = 6371;
    
    // CONVERTIR GRADOS A RADIANES
    // Las funciones trigonom√©tricas de JavaScript requieren radianes
    const dLat = (lat2 - lat1) * Math.PI / 180;  // Diferencia de latitudes en radianes
    const dLng = (lng2 - lng1) * Math.PI / 180;  // Diferencia de longitudes en radianes
    
    console.log(`üìê Diferencias en radianes - Lat: ${dLat}, Lng: ${dLng}`);
    
    // APLICAR F√ìRMULA DE HAVERSINE
    // Esta f√≥rmula calcula la distancia m√°s corta entre dos puntos en una esfera
    // F√≥rmula: a = sin¬≤(Œîlat/2) + cos(lat1) √ó cos(lat2) √ó sin¬≤(Œîlong/2)
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
             Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
             Math.sin(dLng/2) * Math.sin(dLng/2);
             
    // c = 2 √ó atan2(‚àöa, ‚àö(1‚àía))
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    
    // d = R √ó c (distancia en kil√≥metros)
    const distance = R * c;
    
    console.log(`üìè Distancia calculada: ${distance.toFixed(3)} km`);

    // RETORNAR FORMATO APROPIADO SEG√öN LA DISTANCIA
    if (distance < 1) {
        // Si es menos de 1 km, mostrar en metros para mayor precisi√≥n
        const meters = Math.round(distance * 1000);
        console.log(`üìè Resultado: ${meters} metros`);
        return `${meters} m`;
    } else {
        // Si es 1 km o m√°s, mostrar en kil√≥metros con 2 decimales
        const kilometers = distance.toFixed(2);
        console.log(`üìè Resultado: ${kilometers} kil√≥metros`);
        return `${kilometers} km`;
    }
}

/* ========================================
   üìä ACTUALIZAR ESTAD√çSTICAS INFERIORES
   ========================================
   Actualiza las 4 cards de estad√≠sticas que aparecen
   en la parte inferior de la aplicaci√≥n
======================================== */

function updateStats(accuracy) {
    console.log('üìä Actualizando estad√≠sticas...');
    
    // ACTUALIZAR PRECISI√ìN (en metros)
    document.getElementById('accuracyValue').textContent = accuracy?.toFixed(0) || '--';
    
    // ACTUALIZAR CONTADOR DE ACTUALIZACIONES
    document.getElementById('updateCount').textContent = updateCount;
    
    // ACTUALIZAR TIMESTAMP DE √öLTIMA ACTUALIZACI√ìN
    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    
    // NOTA: currentCountry se actualiza en displayAddressInfo() cuando llega la respuesta de las APIs
    
    console.log(`üìä Estad√≠sticas actualizadas - Precisi√≥n: ${accuracy}m, Actualizaciones: ${updateCount}`);
}

/* ========================================
   üö• ACTUALIZAR INDICADORES DE ESTADO
   ========================================
   Controla los peque√±os c√≠rculos de colores que aparecen
   junto a los t√≠tulos de las secciones (verde=activo, rojo=inactivo)
======================================== */

// INDICADOR DE ESTADO PARA GEOLOCALIZACI√ìN
function updateStatus(isActive) {
    const indicator = document.getElementById('statusIndicator');
    // Cambiar clases CSS seg√∫n el estado
    indicator.className = `status-indicator ${isActive ? 'status-active' : 'status-inactive'}`;
    console.log(`üö• Estado GPS: ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
}

// INDICADOR DE ESTADO PARA GEOCODIFICACI√ìN
function updateAddressStatus(isActive) {
    const indicator = document.getElementById('addressStatusIndicator');
    indicator.className = `status-indicator ${isActive ? 'status-active' : 'status-inactive'}`;
    console.log(`üö• Estado Geocodificaci√≥n: ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
}

/* ========================================
   ‚ùå MOSTRAR MENSAJES DE ERROR
   ========================================
   Funci√≥n utilitaria para mostrar errores de forma
   consistente en la interfaz de usuario
======================================== */

function showError(message) {
    console.error(`‚ùå Mostrando error: ${message}`);
    
    // Buscar el panel de informaci√≥n de ubicaci√≥n
    const locationInfo = document.getElementById('locationInfo');
    
    // Mostrar mensaje de error con estilos CSS apropiados
    locationInfo.innerHTML = `<div class="error">${message}</div>`;
}

/* ========================================
   üîÑ SISTEMA DE SEGUIMIENTO EN TIEMPO REAL
   ========================================
   Permite activar/desactivar actualizaciones autom√°ticas
   de ubicaci√≥n cuando el usuario se mueve
======================================== */

// ALTERNAR ESTADO DE SEGUIMIENTO
function toggleTracking() {
    const btn = document.getElementById('trackingBtn');
    console.log(`üîÑ Alternando seguimiento. Estado actual: ${isTracking}`);
    
    if (!isTracking) {
        // ACTIVAR SEGUIMIENTO
        console.log('üü¢ Activando seguimiento autom√°tico...');
        startTracking();
        btn.textContent = 'Detener Seguimiento';
        btn.style.background = 'linear-gradient(135deg, #ff4757 0%, #ff3742 100%)';  // Cambiar a rojo
    } else {
        // DESACTIVAR SEGUIMIENTO
        console.log('üî¥ Desactivando seguimiento autom√°tico...');
        stopTracking();
        btn.textContent = 'Iniciar Seguimiento';
        btn.style.background = 'var(--secondary-gradient)';  // Volver al color original
    }
    
    // Cambiar estado global
    isTracking = !isTracking;
}

// INICIAR SEGUIMIENTO AUTOM√ÅTICO
function startTracking() {
    console.log('üöÄ Iniciando watchPosition...');
    
    const options = {
        enableHighAccuracy: true,    // Usar GPS para m√°xima precisi√≥n
        timeout: 5000,              // Timeout m√°s corto para seguimiento (5 segundos)
        maximumAge: 0               // Siempre obtener nueva ubicaci√≥n
    };

    // üåê WATCHPOSITION - API QUE ACTUALIZA AUTOM√ÅTICAMENTE
    // A diferencia de getCurrentPosition, esta funci√≥n se ejecuta repetidamente
    // cada vez que detecta un cambio en la ubicaci√≥n del usuario
    watchId = navigator.geolocation.watchPosition(
        handleLocationSuccess,    // Se ejecuta cada vez que cambia la ubicaci√≥n
        handleLocationError,      // Se ejecuta si hay errores
        options
    );
    
    console.log(`üéØ watchPosition iniciado con ID: ${watchId}`);
}

// DETENER SEGUIMIENTO AUTOM√ÅTICO
function stopTracking() {
    if (watchId) {
        console.log(`üõë Deteniendo watchPosition con ID: ${watchId}`);
        
        // CANCELAR el seguimiento autom√°tico usando el ID guardado
        navigator.geolocation.clearWatch(watchId);
        watchId = null;  // Limpiar referencia
    } else {
        console.warn('‚ö†Ô∏è No hay watchId para detener');
    }
}

/* ========================================
   üì§ COMPARTIR UBICACI√ìN ACTUAL
   ========================================
   Permite al usuario compartir su ubicaci√≥n usando
   las APIs nativas del navegador (m√≥vil) o portapapeles (desktop)
======================================== */

async function shareLocation() {
    console.log('üì§ Iniciando proceso de compartir ubicaci√≥n...');
    
    // VERIFICAR QUE TENEMOS UBICACI√ìN PARA COMPARTIR
    if (locationHistory.length === 0) {
        console.warn('‚ö†Ô∏è No hay ubicaci√≥n disponible');
        alert('No hay ubicaci√≥n disponible para compartir');
        return;
    }

    // OBTENER LA √öLTIMA UBICACI√ìN REGISTRADA
    const lastLocation = locationHistory[locationHistory.length - 1];
    console.log('üìç Ubicaci√≥n a compartir:', lastLocation);
    
    // CREAR TEXTO Y ENLACE PARA COMPARTIR
    // Usamos Google Maps porque es universalmente reconocido
    const shareText = `Mi ubicaci√≥n actual: https://www.google.com/maps?q=${lastLocation.lat},${lastLocation.lng}`;
    const shareUrl = `https://www.google.com/maps?q=${lastLocation.lat},${lastLocation.lng}`;

    // üåê INTENTAR WEB SHARE API PRIMERO (principalmente m√≥viles)
    if (navigator.share) {
        console.log('üì± Web Share API disponible, usando share nativo...');
        try {
            await navigator.share({
                title: 'Mi Ubicaci√≥n',           // T√≠tulo que aparece en el share
                text: shareText,                 // Texto descriptivo
                url: shareUrl                    // URL a compartir
            });
            console.log('‚úÖ Ubicaci√≥n compartida exitosamente');
        } catch (err) {
            // El usuario cancel√≥ el share o hubo error
            console.log('‚ö†Ô∏è Share cancelado o error:', err);
        }
    } else {
        // üåê FALLBACK: CLIPBOARD API para desktop
        console.log('üíª Web Share API no disponible, usando portapapeles...');
        
        try {
            await navigator.clipboard.writeText(shareText);
            alert('Ubicaci√≥n copiada al portapapeles');
            console.log('‚úÖ Ubicaci√≥n copiada al portapapeles');
        } catch (err) {
            console.error('‚ùå Error copiando al portapapeles:', err);
            alert('Error al copiar la ubicaci√≥n');
        }
    }
}

/* ========================================
   üßπ LIMPIAR RUTAS Y MARCADORES
   ========================================
   Funci√≥n asociada al bot√≥n "Limpiar Ruta"
   que remueve todos los elementos temporales del mapa
======================================== */

function clearRoute() {
    console.log('üßπ Limpiando ruta y marcadores...');
    
    // REMOVER ELEMENTOS DE RUTA (si existen)
    if (routeControl) {
        routeControl.remove();  // Usa la funci√≥n personalizada que creamos
        routeControl = null;    // Limpiar referencia
        console.log('‚úÖ Ruta removida');
    }
    
    // REMOVER MARCADOR ROJO (si existe)
    if (clickedMarker) {
        map.removeLayer(clickedMarker);  // Leaflet funci√≥n para quitar del mapa
        clickedMarker = null;            // Limpiar referencia
        console.log('‚úÖ Marcador rojo removido');
    }
    
    console.log('‚úÖ Limpieza completada');
}


async function getWeatherData(lat, lng) {
    console.log(`üå§Ô∏è Obteniendo datos del clima para: ${lat}, ${lng}`);
    
    try {
        // üåê OPENWEATHERMAP API
        // Necesitas registrarte en https://openweathermap.org/api
        // y reemplazar 'TU_API_KEY' con tu clave real
        const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=TU_API_KEY&units=metric`
        );
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('üå§Ô∏è Datos del clima obtenidos:', data);
        
        // EJEMPLO DE DATOS QUE PUEDES OBTENER:
        // data.main.temp = temperatura actual
        // data.weather[0].description = descripci√≥n del clima
        // data.main.humidity = humedad
        // data.wind.speed = velocidad del viento
        
        return data;
        
    } catch (error) {
        console.error('‚ùå Error obteniendo datos del clima:', error);
        return null;
    }
}

// NUEVA FUNCI√ìN: Mostrar ayuda de permisos
function showPermissionHelp() {
    const locationInfo = document.getElementById('locationInfo');
    locationInfo.innerHTML = `
        <div style="text-align: center; padding: 20px;">
            <h3 style="color: #E53E3E; margin-bottom: 16px;">
                üîí Permisos de Ubicaci√≥n Requeridos
            </h3>
            <p style="margin-bottom: 16px; color: #4A5568;">
                Para usar esta aplicaci√≥n, necesitas permitir el acceso a tu ubicaci√≥n.
            </p>
            <div style="background: rgba(229, 62, 62, 0.1); padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                <p style="font-weight: 600; margin-bottom: 8px;">üõ†Ô∏è C√≥mo activar permisos:</p>
                <ol style="text-align: left; color: #4A5568;">
                    <li>Haz click en el <strong>üîí candado</strong> junto a la URL</li>
                    <li>Busca <strong>"Ubicaci√≥n"</strong></li>
                    <li>Cambia a <strong>"Permitir"</strong></li>
                    <li>Recarga la p√°gina</li>
                </ol>
            </div>
            <button onclick="requestLocation()" class="btn btn-primary">
                üîÑ Intentar de nuevo
            </button>
        </div>
    `;
}

// NUEVA FUNCI√ìN: Solicitar ubicaci√≥n
function requestLocation() {
    const options = {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
        handleLocationSuccess,
        handleLocationError,
        options
    );
}